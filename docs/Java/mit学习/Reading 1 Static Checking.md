---
title: "Reading 1: Static Checking"
tags: [Java,mit,Static Checking]
---
## 静态类型

Java 是一种 **静态类型语言** 。所有变量的类型在**编译时（程序运行之前）**都是已知的，因此编译器也可以推断出所有表达式的类型。如果 `a `和 `b `被声明为 `int `s，那么编译器会断定它 `a+b `也是一个 `int `。事实上，Eclipse 环境会在您编写代码时执行此操作，因此您可以在键入时发现许多错误。

在 Python 等 **动态类型语言** 中 ，这种检查会推迟到**运行时（程序运行时**）。

静态类型是一种特殊的 **静态检查** ，这意味着在编译时检查错误。Bug 是编程的祸根。

本课程中的许多想法旨在消除代码中的错误，而静态检查是我们看到的第一个想法。静态类型可以防止一大类错误感染您的程序：准确地说，是由于将操作应用于错误类型的参数而导致的错误。如果你写了一行断线的代码，例如：

```
   "5" * "6"
```

尝试将两个字符串相乘，那么静态类型将在您仍在编程时捕获此错误，而不是等到执行期间到达该行。

## 静态检查、动态检查、不检查

考虑一种语言可以提供的三种自动检查是很有用的：

- **静态检查** ：在程序运行之前就自动发现错误。
- **动态检查** ：代码执行时自动发现bug。
- **不检查** ：该语言根本无法帮助您找到错误。你必须自己注意，否则最终会得到错误的答案。

不用说，静态捕获错误比动态捕获要好，动态捕获也比根本不捕获要好。

以下是一些经验法则，说明您在每次这些时间中可能会发现哪些错误。

**静态检查** 可以捕获：

- 语法错误，例如多余的标点符号或虚假单词。即使像 Python 这样的动态类型语言也会进行这种静态检查。如果 Python 程序中存在缩进错误，您会在程序开始运行之前发现。
- 错误的名字，比如 `Math.sine(2) `。（正确的名字是 `sin `。）
- 参数数量错误，例如 `Math.sin(30, 20) `.
- 错误的参数类型，例如 `Math.sin("30") `.
- 错误的返回类型，例如 `return "30"; `声明返回 `int `.

**动态检查** 可以捕获：

- 非法参数值。例如，整数表达式 仅在 实际为零` x/y `时才是错误的 ；` y `否则它会起作用。所以在这个表达式中，被零除不是静态误差，而是动态误差。
- 无法表示的返回值，即当特定的返回值无法用类型表示时。
- 超出范围的索引，例如，在字符串上使用负数或太大的索引。
- 在对象引用上调用方法 `null `（ `null `就像 Python 一样 `None `）。

**静态检查通常涉及数据类型，这些错误与变量具体的值无关。**一个数据类型是一组值的集合。静态类型检查保证一个变量会拥有该集合中的某个值，但直到运行时我们才确切知道它拥有哪个值。

因此，如果错误只会由特定的值引起，比如除零或索引越界，那么编译器不会在静态阶段引发关于它的错误。

相比之下，动态检查往往针对特定值引起的错误。

## 惊喜: 原始类型不是真正的数学数值

在Java中，原始数据类型（例如整数和浮点数）**并不是真正的数学数值**。Java 和许多其他编程语言中的一个陷阱是，**其原始数字类型存在一些极端情况，其行为与我们习惯的整数和实数不同**。结果，一些真正应该动态检查的错误根本没有被检查。

以下是陷阱：

1. **整数除法陷阱**：在Java中，整数除法（例如5/2）不会返回一个小数分数，而是返回一个被截断为整数的结果。这就意味着，当期望结果是一个分数时，使用整数除法会得到错误的答案，而不会引发动态错误。这是因为整数无法精确地表示分数。
2. **整数溢出陷阱**：Java的int和long类型是有限的整数集合，具有最大和最小值限制。当进行计算的结果超出了这个有限范围时，**计算会悄悄地溢出（绕回）**，返回一个在合法范围内但不是正确答案的整数。
3. **浮点数和双精度浮点数的特殊值陷阱**：在Java中，float和double类型具有几个特殊值，例如NaN（表示“不是一个数字”）、POSITIVE_INFINITY（正无穷大）和NEGATIVE_INFINITY（负无穷大）。因此，一些本应该产生动态错误的操作，如除以零或对负数进行平方根操作，实际上会产生这些特殊值之一。如果继续对这些特殊值进行计算，最终可能得到错误的最终答案。

## 概括

今天我们介绍的主要思想是 **静态检查** 。以下是这个想法与课程目标的关系：

- **Safe from bugs。** 静态检查通过在运行前捕获类型错误和其他错误来帮助提高安全性。
- **Easy to understand。** 它有助于理解，因为类型在代码中明确说明。
- **Ready for change。** 静态检查可以通过识别其他需要同时更改的位置来更轻松地更改代码。例如，当您更改变量的名称或类型时，编译器会立即在所有使用该变量的地方显示错误，提醒您也进行更新。
